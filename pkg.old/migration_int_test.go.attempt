package pkg

import (
	"gopkg.in/yaml.v2"
	"helm.sh/helm/v3/pkg/chart"
	"helm.sh/helm/v3/pkg/release"
	"helm.sh/helm/v3/pkg/time"
	"testing"
)

func TestMigrator_IntegrationTests(t *testing.T) {

	defaultValuesV1 := `agent:
  targetEnvironments: []`

	templateV1 := `apiVersion: apps/v1
kind: Deployment
metadata:
  name: "this-chart"
  namespace: {{ .Release.Namespace | quote }}
  labels:
    {{- include "kubernetes-agent.labels" . | nindent 4 }}
spec:
  template:
    spec:
      containers:
        - name: {{ .Chart.Name }}
        env:
          - name: "TargetEnvironment"
          value: {{ join "," .Values.agent.targetEnvironments | quote }}`

	defaultValuesV2 := `agent:
  target:
    environments: []`

	templateV2 := `apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{printf "%s-tentacle" (include "kubernetes-agent.name" .) }}
  namespace: {{ .Release.Namespace | quote }}
  labels:
    {{- include "kubernetes-agent.labels" . | nindent 4 }}
spec:
  template:
    spec:
      containers:
        - name: {{ .Chart.Name }}
        env:
          target:
            environments: [{{ .Values.agent.target.environments | quoteEach | join "," }}]`

	migration := `agent:
  target:
    environments: [{{ .agent.targetEnvironments | quoteEach | join ","}}]`

	//Make an existing chart
	chV1 := &chart.Chart{
		Metadata: &chart.Metadata{
			APIVersion: chart.APIVersionV1,
			Name:       "testUpgradeChart",
			Version:    "1.0.0",
		},
		Templates: []*chart.File{{Name: "templates/deployment.yaml", Data: []byte(templateV1)}},
	}
	_ = yaml.Unmarshal([]byte(defaultValuesV1), &chV1.Values)

	r := getMockRelease(chV1)

	//Make a migration
	ms := NewMockMigrations()
	m := newMigration("2.0.0")
	ms.AddMigrationData(m, migration)

	chV2 := &chart.Chart{
		Metadata: &chart.Metadata{
			APIVersion: chart.APIVersionV1,
			Name:       "testUpgradeChart",
			Version:    "2.0.0",
		},
		Templates: []*chart.File{{Name: "templates/deployment.yaml", Data: []byte(templateV2)}},
	}
	_ = yaml.Unmarshal([]byte(defaultValuesV2), &chV2.Values)

	//Migrate the chart
	migratedValues, err := Migrate(r.Config, nil, ms)
	if err != nil {
		t.Errorf("Error migrating values: %v", err)
	}

	//apply migrated values to the new chart

	upAction := upgradeAction(t)

	existingValues := map[string]interface{}{
		"name":        "value",
		"maxHeapSize": "128m",
		"replicas":    2,
	}
	newValues := map[string]interface{}{
		"name":        "newValue",
		"maxHeapSize": "512m",
		"cpu":         "12m",
	}
	expectedValues := map[string]interface{}{
		"name":        "newValue",
		"maxHeapSize": "512m",
		"cpu":         "12m",
		"replicas":    2,
	}

	rel := releaseStub()
	rel.Name = "nuketown"
	rel.Info.Status = release.StatusDeployed
	rel.Config = existingValues

	err := upAction.cfg.Releases.Create(rel)
	is.NoError(err)

	upAction.ReuseValues = true
	// setting newValues and upgrading
	rel2, err := upAction.Run(rel.Name, buildChart(), newValues)
	is.NoError(err)

	// Now make sure it is actually upgraded
	updatedRel, err := upAction.cfg.Releases.Get(rel2.Name, 2)
	is.NoError(err)

	if updatedRel == nil {
		is.Fail("Updated Release is nil")
		return
	}
	is.Equal(release.StatusDeployed, updatedRel.Info.Status)
	is.Equal(expectedValues, updatedRel.Config)

}

func upgradeAction(t *testing.T) *Upgrade {
	config := actionConfigFixture(t)
	upAction := NewUpgrade(config)
	upAction.Namespace = "spaced"

	return upAction
}

func getMockRelease(ch *chart.Chart) *release.Release {

	date := time.Unix(374072400, 0).UTC()
	info := &release.Info{
		FirstDeployed: date,
		LastDeployed:  date,
		Status:        release.StatusDeployed,
	}

	// TODO: narrow down what we actually need here
	return &release.Release{
		Name:      "mock-release",
		Info:      info,
		Chart:     ch,
		Config:    map[string]interface{}{"name": "value"},
		Version:   1,
		Namespace: "namespace",
		Manifest:  MockManifest,
	}
}

var MockManifest = `apiVersion: v1
kind: Secret
metadata:
  name: fixture
`
